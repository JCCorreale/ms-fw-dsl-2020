System butlermind

mqttBroker "localhost" : 1883    //192.168.1.18  192.168.43.229 

// From the maitre
Dispatch prepare : prepare
Dispatch stop : stop
Dispatch reactivate : reactivate

// From/to carrierbehavior
Dispatch setGoal : setGoal(G)
Dispatch suspend : suspend
Dispatch resume : resume
Dispatch goalReached : goalReached

// To roomstate
Dispatch take : take(Item, Location)
Dispatch put : put(Item, Location)

Context ctxButlermind     ip [host="localhost" port=8105]  -mqtt
Context ctxDummyForFridge     ip [host="localhost" port=8095]  -mqtt
Context ctxDummyForCarrier     ip [host="localhost" port=8042]  -mqtt

ExternalQActor resourcemodel context ctxDummyForFridge // FRIDGE resource model!

ExternalQActor carrierbehavior context ctxDummyForCarrier

QActor roomstate context ctxButlermind {
	
	State s0 initial {		  
		solve( consult("roomState.pl") )
		solve( showContent )
		// Register to fridge COAP resource
		run itunibo.jcc.coap.roomstate.roomModelFridgeObserver.create(myself)
		// Create COAP resource
		run itunibo.jcc.coap.roomstate.roomModelResourceCoap.create( myself, "roomstate" ) //CoAP access
	}
	Goto waitModelChange
	
	State waitModelChange{ }
	Transition t0 whenMsg take -> updateModel
			 	  whenMsg put -> updateModel
//	              whenMsg modelUpdate -> updateModel

	State updateModel{
		printCurrentMessage
		// TODO
		onMsg( take : take(Item, Location) ) {
			if "payloadArg(1) == \"fridge\""  { 			
				// TODO Update via COAP
				forward resourcemodel -m take : take($payloadArg(0))
			}
			else {
				solve( retract( at( $payloadArg(0), $payloadArg(1) ) ) )
				ifSolved {
	//				run itunibo.jcc.coap.fridge.fridgeResourceCoap.resourceCoap.updateState()
				}
				else {
					println("*** Can't take non-existing content! ***")
				}
				// TODO Update COAP resource
				//run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
			}
			solve( showContent )
		}
		onMsg( put : put(Item, Location) ) {
			if "payloadArg(1) == \"fridge\""  { 				
				// TODO Update via COAP
				forward resourcemodel -m put : put($payloadArg(0))
			}
			else {
				solve( assert( at( $payloadArg(0), $payloadArg(1) ) ) )
				// Always solved
				ifSolved {
	//				run itunibo.jcc.coap.fridge.fridgeResourceCoap.resourceCoap.updateState()
				}
				// TODO Update COAP resource
				//run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )	
			}
			solve( showContent )
		}
	}
    Goto  waitModelChange

//
//	State updateModel{  
//		printCurrentMessage
//		onMsg( modelUpdate : modelUpdate(robot,V ) ) {
//			run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
//		}
//		onMsg( modelUpdate : modelUpdate(sonarRobot,V ) ) {
//			run itunibo.robot.resourceModelSupport.updateSonarRobotModel( myself, payloadArg(1) )
//		}
//		onMsg( modelUpdate : modelUpdate(roomMap,V ) ) {  //JULY19
//			println("modelUpdate roomMap  ")
//			run itunibo.robot.resourceModelSupport.updateRoomMapModel( myself, payloadArg(1) )
//		}
//	} 
//    Goto  waitModelChange
//    
//	State changeModel{  
//		//printCurrentMessage 
//		//ROBOT MOVE
//		onMsg( modelChange : modelChange( robot,V ) ) { // V= w | ...
//			run itunibo.robot.resourceModelSupport.updateRobotModel( myself, payloadArg(1) )
//			emit local_modelChanged : modelChanged(  robot,  $payloadArg(1))  //for the robotmind
//		} 
//		//SONAR DATA  
////		onMsg( modelChange : modelChange( sonarRobot,V ) ) { // V= w | ...
////			run itunibo.robot.resourceModelSupport.updateSonarRobotModel( myself, payloadArg(1) )
////		}
//	}  
//	Goto  waitModelChange
}

QActor butlermind context ctxButlermind {
	State s0 initial {

		// TODO
	  
//		solve( consult("roomState.pl") )
//		solve( showContent )
//		// Register to fridge COAP resource
//		run itunibo.jcc.coap.roomstate.roomModelFridgeObserver.create(myself)
//		// Create COAP resource
////		run itunibo.jcc.coap.fridge.fridgeResourceCoap.create( myself, "fridgeresource" ) //CoAP access
	}
	Goto waitCommand
	 
	State waitCommand{ }
	Transition t0 whenMsg prepare -> doPrepare
				  whenMsg stop -> suspend // TODO Workaround

	State doPrepare{
		
		// TODO Goals from prolog file
		
		// One goal at a time (current planner too slow for conjunctions of goals)
		forward carrierbehavior -m setGoal : setGoal( at(pizza, table) )
		forward carrierbehavior -m setGoal : setGoal( at(caviar, table) )
		forward carrierbehavior -m setGoal : setGoal( at(dishes, table) )
		forward carrierbehavior -m setGoal : setGoal( at(butler, home) )
	}
	Goto handleSuspendResume
	
	State handleSuspendResume{
		println("butlermind | handleSuspendResume")
	}
	Transition t0 whenEvent goalReached -> waitCommand
				  whenMsg stop -> suspend
				  
	State suspend{
		println("butlermind | suspend")
		forward carrierbehavior -m suspend : suspend
	}
	Transition t0 whenMsg reactivate -> resume
	
	State resume{
		println("butlermind | resume")
		forward carrierbehavior -m resume : resume
	}
	Goto handleSuspendResume
}