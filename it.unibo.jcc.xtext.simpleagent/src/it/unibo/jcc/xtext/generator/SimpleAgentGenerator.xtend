/*
 * generated by Xtext 2.17.0
 */
package it.unibo.jcc.xtext.generator

import static extension it.unibo.jcc.xtext.generator.common.AgentExtensions.*

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import it.unibo.jcc.xtext.generator.common.GenUtils
import it.unibo.jcc.xtext.simpleAgent.Action
import it.unibo.jcc.xtext.simpleAgent.OnEffect
import it.unibo.jcc.xtext.simpleAgent.Behavior
import it.unibo.jcc.xtext.simpleAgent.BehaviorDeclaration
import it.unibo.jcc.xtext.simpleAgent.BehaviorExternal
import it.unibo.jcc.xtext.simpleAgent.Compensation

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SimpleAgentGenerator extends AbstractGenerator {

	
	/* GENERATION */

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		GenUtils.setFsa(fsa)
	    GenUtils.setFileExtension(resource.URI.fileExtension)
	    GenUtils.genFileDir(".", "", resource.agentName, "qak", generateSimpleAgent(resource))
	}
	
	def generateSimpleAgent(Resource resource) '''
		System «resource.systemName»
		«resource.mqttBroker»
		«genMessages(resource)»
		«genContexts(resource)»
		«genBehaviors(resource)»
	'''
	
	def genMessages(Resource resource) '''
		// Commands for the worker
		Dispatch setGoal	   : setGoal(G)
		Dispatch suspend	   : suspend
		Dispatch resume        : resume
		// Events from the worker
		Event goalReached      : goalReached
		// User-defined messages
		«FOR message:resource.agent.system.message»
		«message.stringContent»
		«ENDFOR»
		// Action messages
		«genActionDispatches(resource.behavior)»
		// Infrastructure messages
		Dispatch retry 		: retry
		Dispatch replan 	: replan
		Dispatch setGoal 	: setGoal
	'''
	
	def genContexts(Resource resource)'''
		Context «resource.contextName» ip [host="«resource.host»" port=«resource.port»] «resource.mqtt»
		«FOR context:resource.agent.system.context»
		«context.stringContent»
		«ENDFOR»
	'''
	
	def genBehaviors(Resource resource) '''
		«FOR behavior:resource.agent.behaviors»
		«genBehavior(behavior, resource.contextName)»
		«ENDFOR»
	'''
	
	def dispatch genBehavior(BehaviorDeclaration behavior, String context) '''not here genBehavior'''
	
	def dispatch genBehavior(BehaviorExternal behavior, String context) '''
		ExternalQActor «behavior.name» context «behavior.context.name»
	'''
	
	def dispatch genBehavior(Behavior behavior, String context) '''
		QActor «behavior.actorName» context «context» {
		["

		var Curmove     = \"\" 
		var suspended = false

		var CurGoal = \"\"
		
		var GoalSender = \"\"
		
		//var CurGoalX = \"\"
		//var CurGoalY = \"\"
		
		«IF (behavior.start !== null)»
		«behavior.start.body»
		«ENDIF»
		
		// From Planner declaration
		val planner = «behavior.planner.replace("^", "")/* TODO Workaround! */»()
		"]
			State s0 initial {
				«IF (behavior.init !== null)»
				«behavior.init.stringContent»
				//solve( consult("moves.pl") )
				//run itunibo.planner.plannerUtil.initAI()
				//run itunibo.planner.moveUtils.loadRoomMap( myself, mapname )
				//run itunibo.planner.moveUtils.showCurrentRobotState()
				//["val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()"]
				//forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)
			«ENDIF»
			}
		 	Goto waitGoal
		 	
		 	State waitGoal {
		 		println("Waiting for goal...")	
		 	}
		 	Transition setGoalT whenMsg setGoal -> setGoal
			 
			State setGoal {
				println("here in setGoal")
				printCurrentMessage
				onMsg( setGoal : setGoal(G) ) {
					println("Received setGoal")
					["planner.planGoal(myself, payloadArg(0))"]
					//run itunibo.planner.plannerUtil.setGoal(payloadArg(0), payloadArg(1))
		  			//run itunibo.planner.moveUtils.doPlan( myself )
		  			// To allow replanning
		  			["CurGoal = payloadArg(0)"]
		  			["GoalSender = currentMsg.msgSender()"]
		  			//["CurGoalX = payloadArg(0)"]
		  			//["CurGoalY = payloadArg(1)"]
		 			//solve( dialog(F) )
				}
				
				// TODO What if no plan can be calculated?
		   	}
		   	Goto suspendOrExecute
			//Goto executePlannedActions //doGoHomeActions 
			
			State suspendOrExecute {}
				Transition checkSuspend 
			   		whenTime 200 -> executePlannedActions
			   		whenMsg suspend -> suspended	
			
			State suspended {
				«IF behavior.onSuspended !== null»
				«behavior.onSuspended.stringContent»
				«ENDIF»
				// Send stop command
				//forward resourcemodel -m modelChange : modelChange(robot,h)
				//println("suspended")		
			}
			Transition resume whenMsg resume -> resume // suspendOrExecute ?
			
			State resume {
				«IF behavior.onResumed !== null»
				«behavior.onResumed.stringContent»
				«ENDIF»
			}
			Goto executePlannedActions
			
			State executePlannedActions{
				//solve( showMoves ) 
				// retract only after it's executed
				solve( move(M) )
				//solve( retract( move(M) ) )
				ifSolved {  
					["Curmove = getCurSol(\"M\").toString()"]
				}
				else { ["Curmove = \"\""] } 
				println("executePlannedActions doing $Curmove")
		 	}
		   
			Goto checkAndDoAction if "(Curmove.length>0) " else goalOk 
		
		 	State goalOk{
		 		«IF behavior.onSuspended !== null»
		 		«behavior.onGoalReached.stringContent»
		 		«ENDIF»
		 		//run itunibo.planner.moveUtils.showCurrentRobotState()
			 	//["	val MapStr =  itunibo.planner.plannerUtil.getMapOneLine()  "]
			 	//forward resourcemodel -m modelUpdate : modelUpdate(roomMap,$MapStr)
			 	
			 	//emit goalReached : goalReached
			 	["forward(\"goalReached\", \"goalReached\", GoalSender)"]
		 	}
		 	Goto waitGoal
		 	
			«genCheckAndDoAction(behavior)»
			 	
			«genActionStates(behavior)»
			 	
			«genActionsOnStates(behavior)»
			
			«genActionOnEffectCompensationStates(behavior)»
			 	
			State finalizeMove {
				// Move actually succeded
				//["retryCount = 0"]
				solve( retract( move(M) ) )
			}
			Goto suspendOrExecute
			
			/*
			
			State retry { // TODO Really needed?
					
				//println("retry ${Curmove} in ${Tretry} ms")
				//["retryCount++"]
				
		//		println("MOVES BEFORE REASSERT")
		//		solve( showMoves ) 
		//		println("END MOVES BEFORE REASSERT")
		
		//		// reassert current move
		//		solve( assert( move($Curmove) ) )
		//		// 
		//		println("MOVES AFTER REASSERT")
		//		solve( showMoves ) 
		//		println("END MOVES AFTER REASSERT")
			}
			//Transition t0 whenTimeVar Tretry -> suspendOrExecute
			Goto suspendOrExecute
			
			State replan {
				
				println("replanning")
				
				//["retryCount = 0"]
				// Puts the obstacle on the map
				//run itunibo.planner.moveUtils.setObstacleOnCurrentDirection(myself)
				//run itunibo.planner.plannerUtil.showMap()  //
				// Clear previous plan
				solve( retractall( move(M) ) )
				forward «behavior.actorName» -m setGoal : setGoal($CurGoal)
			}
			Transition t0 whenMsg setGoal -> setGoal
			
			*/
		}
	'''
	
	def genActionsOnStates(Behavior behavior) '''
		«FOR action:behavior.actions»«genActionOnStates(behavior.actorName, action)»«ENDFOR»
		
	'''
	
	def genActionOnStates(String actorName, Action action) '''
		«FOR on:action.on»
		«genActionOnState(actorName, action.actions.toList.map[head].join("_"), on)»
		«ENDFOR»
	'''
	
	def genActionOnState(String actorName, String actionName, OnEffect on) '''
		State «actionName»_on«on.effect.name.toFirstUpper»{ // TODO HANDLE MESSAGE NAMES BETTER!!!
			// from "agent" code
			«on.body.stringContent»
			// TODO Check consistency with QActor guarded transitions policy
			«IF on.compensations.size > 0»
			«genCompensationCondition(actorName, on.compensations.get(0), true)»
			«IF on.compensations.size > 1»
			«FOR compensation:on.compensations.subList(1, on.compensations.length)»
			«genCompensationCondition(actorName, compensation, false)»
			«ENDFOR»
			«ENDIF»
			«ENDIF»
		}
		«IF on.compensations.size > 0»
		Transition compensation
			«genCompensationTransitions(actionName, on)»
		«ELSE»
		Goto finalizeMove
		«ENDIF»
	'''
	
	def genActionOnEffectCompensationStates(Behavior behavior) '''
		«FOR action:behavior.actions»
		«FOR on:action.on»
		«FOR compensation:on.compensations»
		«genActionOnEffectCompensationState(behavior.actorName, action.actions.toList.map[head].join("_"), compensation)»
		
		«ENDFOR»
		«ENDFOR»
		«ENDFOR»
	'''
	
	def genActionOnEffectCompensationState(String actorName, String actionName, Compensation compensation) '''
		State «actionName»_«compensation.type» { // TODO Currently only one compensation per type allowed (specify in grammar?)
			«IF compensation.body !== null»
			«compensation.body.stringContent»
			«ENDIF»
			«IF compensation.type != "retry"»
			// Clear previous plan
			solve( retractall( move(M) ) )
			«IF compensation.type == "replan"»
			forward «actorName» -m setGoal : setGoal($CurGoal)
			«ELSE»
			forward «actorName» -m setGoal : setGoal(«compensation.goal»)
			«ENDIF»
			«ENDIF»
		}
		«IF compensation.type == "retry"»
		Goto suspendOrExecute
		«ELSE»
		Transition t0 whenMsg setGoal -> setGoal
		«ENDIF»
	'''
	
	def genCompensationCondition(String actorName, Compensation compensation, boolean first) '''
		["«IF !first»else «ENDIF»if («compensation.condition») {"]
			forward «actorName» -m «compensation.type» : «compensation.type»
		["}"]
	'''
	
	def genCompensationTransitions(String actionName, OnEffect on) '''
		«FOR compensation:on.compensations»
		«genCompensationTransition(actionName, compensation)»
		«ENDFOR»
	'''
	
	def genCompensationTransition(String actionName, Compensation compensation) '''
		whenMsg «compensation.type»  -> «actionName»_«compensation.type» // TODO Handles only one compensation per ACTION (on a single Effect)!!!
	'''
	
	def genActionStates(Behavior behavior) '''
		«FOR action:behavior.actions»«genActionState(action)»«ENDFOR»
		
	'''
	
	def genActionState(Action action) '''
		State «action.actions.toList.map[head].join("_")» {
			«genActionOnMsgs(action)»
		}
		«IF action.on.size > 0»
		Transition t0
			// from "on(...)" clauses on action w
			«FOR on:action.on»«getActionStateTransition(action.actions.toList.map[head].join("_"), on)»«ENDFOR»
		«ELSE»
		Goto finalizeMove // No "on(...)" clause specified
		«ENDIF»
		
	'''
	
	def genActionOnMsgs(Action action)'''
		«FOR phead:action.actions»
		onMsg(«phead.head» : «phead.stringContent») { // TODO Better handling of multiple actions!
			// from "agent" code
			«action.body.stringContent»
		}
		«ENDFOR»
	'''
	
	def getActionStateTransition(String actionName, OnEffect on) '''
		whenMsg «on.effect.name»	-> «actionName»_on«on.effect.name.toFirstUpper»
	'''
	
	def genCheckAndDoAction(Behavior behavior) '''
		State checkAndDoAction{
			solve( assert( curmove($Curmove) ) )
			//["when (Curmove) {"]
			// TODO Assuming only one solves
			«FOR action:behavior.actions»
				«genActionCase(action, behavior.actorName)»
			«ENDFOR»
			solve( retract( curmove($Curmove) ) )
			//["}"]
		}
		Transition t0 
			«FOR action:behavior.actions»«genActionTransitions(action)»«ENDFOR»
	'''
	
	def genActionTransitions(String actionMessageName, String actionStateName) '''
		whenMsg «actionMessageName» -> «actionStateName»
	'''
	
	def genActionTransitions(Action action)'''
		«FOR phead:action.actions»
		whenMsg «phead.head» -> «action.actions.toList.map[head].join("_")» // TODO Better handling of multiple actions!
		«ENDFOR»
	'''
	
//	def genActionCase(String agentName, String actionName, String actionGroup) '''
//		//["	\"«actionName»\" -> "]
//		solve( curmove( «actionName» ) )
//		ifSolved {
//			forward «agentName» -m «actionName» : $Curmove // «actionGroup»
//		} // TODO else?
//	'''

	def genActionCase(Action action, String agentName) '''
		«FOR phead:action.actions»
		//["	\"«phead.head»\" -> "]
		solve( curmove( «phead.stringContent» ) )
		ifSolved {
			forward «agentName» -m «phead.head» : $Curmove
		} // TODO else?
		«ENDFOR»
	'''
	
	def genActionDispatches(Behavior behavior) '''
		«FOR action:behavior.actions»«genActionDispatches(action)»«ENDFOR»
	'''
	
	def genActionDispatches(Action action)'''
		«FOR phead:action.actions»
		Dispatch «phead.head/*action.actions.toList.map[head].join("_")*/» 	   : «phead.stringContent» // TODO Better handling of multiple actions!
		«ENDFOR»
	'''
}